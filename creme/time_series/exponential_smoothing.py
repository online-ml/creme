from typing import List, Optional
import collections  # replace by creme utils windows
from . import base


def _discount_sum(phi: float, h: int) -> list:
    return sum([phi**i for i in range(1, h + 1)])


class SimpleExponentialSmoothing(base.Forecaster):
    """
     Simple exponential smoothing.
     Mathematically, it is defined as:
     Forecast equation
     .. math:: \hat{y}_{t+h | t}=\ell_{t}
     Smoothing equation
     .. math:: \ell_{t}=\alpha y_{t}+(1-\alpha) \ell_{t-1} 

    Parameters:
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 . Defaults to `0.5`.
        l0 (float): Initialization value for the level. Defaults to `0`.

    Example:
        ::
            >>> #TODO

    References:
        1. `Simple exponential smoothing <https://otexts.com/fpp2/ses.html>`_
    """

    def __init__(self, alpha=0.5, l0: float = 0):

        self.alpha = alpha

        self.lt = l0

    def fit_one(self, y: float):
        self.st = self.alpha * y + (1 - self.alpha) * self.lt

        return self

    def forecast(self, horizon: int) -> list:
        return [self.lt for _ in range(horizon)]


class HoltLinearTrend(base.Forecaster):
    """
    Holt (1957) extended simple exponential smoothing to allow the forecasting
    of data with a trend. This method involves a forecast equation and
    two smoothing equations (one for the level and one for the trend).
    Mathematically, it is defined as:
    Forecast equation
    .. math:: \hat{y}_{t+h | t}=\ell_{t}+h b_{t}
    Level equation
    .. math:: \ell_{t}=\alpha y_{t}+(1-\alpha)\left(\ell_{t-1}+b_{t-1}\right)
    Trend equation
    .. math:: b_{t}=\beta^{*}\left(\ell_{t}-\ell_{t-1}\right)+\left(1-\beta^{*}\right) b_{t-1}

    Parameters:
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 .Defaults to `0.5`.
        beta (float): The smoothing parameter for the trend, 0 ≤ beta ≤ 1 .Defaults to `0.5`.
        l0 (float): Initialization value for the level. Defaults to `0`.
        b0 (float): Initialization value for the trend. Defaults to `0`.

    Example:
    ::
        >>> #TODO

    References:
        1. `Holt’s linear trend method <https://otexts.com/fpp2/holt.html>`_
    """

    def __init__(self,
                 alpha: float = 0.5,
                 beta: float = 0.5,
                 l0: float = 0,
                 b0: float = 0):

        self.alpha = alpha
        self.beta = beta

        self.lt = l0
        self.bt = b0

    def fit_one(self, y: float):

        lt_1 = self.lt
        bt_1 = self.bt

        self.lt = self.alpha * y + (1 - self.alpha) * (lt_1 + bt_1)
        self.bt = self.beta * (self.lt - lt_1) + (1 - self.beta) * bt_1

        return self

    def forecast(self, horizon: int) -> float:
        return [self.lt + (h * self.bt) for h in range(1, horizon + 1)]


class DampedTrend(base.Forecaster):
    """
    The forecasts generated by Holt’s linear method display a constant trend
    (increasing or decreasing) indefinitely into the future.
    Empirical evidence indicates that these methods tend to over-forecast,
    especially for longer forecast horizons.
    Motivated by this observation, Gardner & McKenzie (1985) introduced
    a parameter that “dampens” the trend to a flat line some time in the future.
    Forecast equation
    .. math:: \hat{y}_{t+h | t}=\ell_{t}+\left(\phi+\phi^{2}+\cdots+\phi^{h}\right) b_{t}
    Level equation
    .. math:: \ell_{t}=\alpha y_{t}+(1-\alpha)\left(\ell_{t-1}+\phi b_{t-1}\right)
    Trend equation
    .. math:: b_{t}=\beta^{*}\left(\ell_{t}-\ell_{t-1}\right)+\left(1-\beta^{*}\right) \phi b_{t-1}

    Parameters:
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 .Defaults to `0.5`.
        beta (float): The smoothing parameter for the trend, 0 ≤ beta ≤ 1 .Defaults to `0.5`.
        phi (float): damping parameter  0 < phi < 1. Defaults to `0.8`.
        l0 (float): Initialization value for the level. Defaults to `0`.
        b0 (float): Initialization value for the trend. Defaults to `0`.

    Example:
    ::
        >>> #TODO

    References:
        1. `Damped trend methods <https://otexts.com/fpp2/holt.html>`_
    """

    def __init__(self,
                 alpha: float = 0.5,
                 beta: float = 0.5,
                 phi: float = 0.8,
                 l0: float = 0,
                 b0: float = 0):

        self.alpha = alpha
        self.beta = beta
        self.phi = phi

        self.lt = l0
        self.bt = b0

    def fit_one(self, y):

        lt_1 = self.lt
        bt_1 = self.bt

        self.lt = self.alpha * y + (1 - self.alpha) * (lt_1 + self.phi * bt_1)
        self.bt = self.beta * (self.lt - lt_1) + (
            1 - self.beta) * bt_1 * self.phi

        return self

    def forecast(self, horizon: int) -> list:
        return [
            self.lt + (_discount_sum(self.phi, h) * self.bt)
            for h in range(1, horizon + 1)
        ]


class HoltWinterAdditive(base.Forecaster):
    """
    Holt (1957) and Winters (1960) extended Holt’s method to capture seasonality.
    The Holt-Winters seasonal method comprises the forecast equation
    and three smoothing equations — one for the level  $l_{t}$,
    one for the trend $b_{t}$ , and one for the seasonal component $s_{t}$,
    with corresponding smoothing parameters alpha, beta and gamma.
    We use m to denote the frequency of the seasonality, 
    i.e., the number of seasons in a year. For example, for quarterly data  m=4, and for monthly data  m=12.

    Parameters:
        m (int): m the frequency of the seasonality
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 . Defaults to `0.5`.
        beta (float): The smoothing parameter for the trend, 0 ≤ beta ≤ 1 . Defaults to `0.5`.
        gamma (float): The smoothing parameter seasonal component 0 ≤ gamma ≤ 1. Defaults to `0.5`.
        s (List[float]): Initialization values for the seasonality. Defaults to `None`.
        l0 (float): Initialization value for the level. Defaults to `0`.
        b0 (float): Initialization value for the trend. Defaults to `0`.

    Example:
    ::
        >>> #TODO

    References:
        1. `Holt-Winters’ additive method <https://otexts.com/fpp2/holt-winters.html>`_
    """

    def __init__(
            self,
            m: int,
            alpha: float = 0.5,
            beta: float = 0.5,
            gamma: float = 0.5,
            s: Optional[List[float]] = None,  # We can discuss for this choice 
            l0: float = 0,
            b0: float = 0):

        self.m = m

        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma

        # init s : [s_{t-m}, s_{t-m+1}, ..., s_{t}]
        if s is None:
            self.s = collections.deque([0 for _ in range(m)], maxlen=m)
        else:
            self.s = collections.deque(s, maxlen=m)

        self.lt = l0
        self.bt = b0

    def fit_one(self, y: float):

        st_1 = self.s[-1]
        st_m = self.s[-self.m]

        lt_1 = self.lt
        bt_1 = self.bt

        self.lt = self.alpha * (y - st_m) + (1 - self.alpha) * (lt_1 + bt_1)
        self.bt = self.beta * (self.lt - lt_1) + (1 - self.beta) * bt_1
        st = self.gamma * (y - lt_1 - bt_1) + (1 - self.gamma) * st_m
        self.s.append(st)

        return self

    def forecast(self, horizon: int) -> list:
        return [
            self.lt + h * self.bt + self.s[h - self.m * ((
                (h - 1) // self.m) + 1)] for h in range(1, horizon + 1)
        ]


class HoltWinterMultiplicative(base.Forecaster):
    """
    #TODO : Docstring + test

    Parameters:
        m (int): m the frequency of the seasonality
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 . Defaults to `0.5`.
        beta (float): The smoothing parameter for the trend, 0 ≤ beta ≤ 1 . Defaults to `0.5`.
        gamma (float): The smoothing parameter seasonal component 0 ≤ gamma ≤ 1. Defaults to `0.5`.
        s (List[float]): Initialization values for the seasonality. Defaults to `None`.
        l0 (float): Initialization value for the level. Defaults to `0.5`.
        b0 (float): Initialization value for the trend. Defaults to `0.5`.

    Example:
    ::
        >>> #TODO

    References:
        1. `Holt-Winters’ multiplicative method <https://otexts.com/fpp2/holt-winters.html>`_
    """

    def __init__(
            self,
            m: int,
            alpha: float = 0.5,
            beta: float = 0.5,
            gamma: float = 0.5,
            s: Optional[List[float]] = None,  # We can discuss for this choice
            l0: float = 0.5,
            b0: float = 0.5):

        self.m = m

        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma

        # init s : [s_{t-m}, s_{t-m+1}, ..., s_{t}]
        if s is None:
            self.s = collections.deque([1 for _ in range(m)], maxlen=m)
        else:
            self.s = collections.deque(s, maxlen=m)

        self.lt = l0
        self.bt = b0

    def fit_one(self, y: float):

        st_1 = self.s[-1]
        st_m = self.s[-self.m]

        lt_1 = self.lt
        bt_1 = self.bt

        # replace by safe division
        self.lt = self.alpha * (y / st_m) + (1 - self.alpha) * (lt_1 + bt_1)
        self.bt = self.beta * (self.lt - lt_1) + (1 - self.beta) * bt_1
        st = self.gamma * (y / (lt_1 + bt_1)) + (1 - self.gamma) * st_m
        self.s.append(st)

        return self

    def forecast(self, horizon: int) -> list:
        return [(self.lt + h * self.bt) * self.s[h - self.m * ((
            (h - 1) // self.m) + 1)] for h in range(1, horizon + 1)]


class HoltWinterDamped(base.Forecaster):
    """
        #TODO : Docstring + test

    Parameters:
        m (int): m the frequency of the seasonality.
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 . Defaults to `0.5`.
        beta (float): The smoothing parameter for the trend, 0 ≤ beta ≤ 1 . Defaults to `0.5`.
        gamma (float): The smoothing parameter seasonal component 0 ≤ gamma ≤ 1. Defaults to `0.5`.
        phi (float): damping parameter  0 < phi < 1. Defaults to `0.8`.
        s (List[float]): Initialization values for the seasonality. Defaults to `None`.
        l0 (float): Initialization value for the level. Defaults to `0.5`.
        b0 (float): Initialization value for the trend. Defaults to `0.5`.


    Example:
    ::
        >>> #TODO

    References:
        1. `Holt-Winters’ damped method <https://otexts.com/fpp2/holt-winters.html>`_
    """

    def __init__(
            self,
            m: int,
            alpha: float = 0.5,
            beta: float = 0.5,
            gamma: float = 0.5,
            phi: float = 0.5,
            s: Optional[List[float]] = None,  # We can discuss for this choice
            l0: float = 0.5,
            b0: float = 0.5):

        self.m = m

        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.phi = phi

        # init s : [s_{t-m}, s_{t-m+1}, ..., s_{t}]
        if s is None:
            self.s = collections.deque([1 for _ in range(m)], maxlen=m)
        else:
            self.s = collections.deque(s, maxlen=m)

        self.lt = l0
        self.bt = b0

    def fit_one(self, y: float):

        st_1 = self.s[-1]
        st_m = self.s[-self.m]

        lt_1 = self.lt
        bt_1 = self.bt

        # replace by safe division
        self.lt = self.alpha * (y / st_m) + (1 - self.alpha) * (
            lt_1 + self.phi * bt_1)
        self.bt = self.beta * (self.lt - lt_1) + (
            1 - self.beta) * self.phi * bt_1
        st = self.gamma * (y /
                           (lt_1 + self.phi * bt_1)) + (1 - self.gamma) * st_m
        self.s.append(st)

        return self

    def forecast(self, horizon: int) -> float:
        return [(self.lt + _discount_sum(self.phi, h) * self.bt) *
                self.s[h - self.m * (((h - 1) // self.m) + 1)]
                for h in range(1, horizon + 1)]


#TODO Trend No and Seasonal additive
class AdditiveSeasonal(base.Forecaster):  # Need better naming
    """
         #TODO : Docstring + test
    Parameters:
        m (int): m the frequency of the seasonality.
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 . Defaults to `0.5`.
        gamma (float): The smoothing parameter seasonal component 0 ≤ gamma ≤ 1. Defaults to `0.5`.
        s (List[float]): Initialization values for the seasonality. Defaults to `None`.
        l0 (float): Initialization value for the level. Defaults to `0.5`.

    Example:
    ::
        >>> #TODO

    References:
        1. `Holt-Winters’ damped method <https://otexts.com/fpp2/taxonomy.html>`_
    """

    def __init__(
            self,
            m: int,
            alpha: float = 0.5,
            gamma: float = 0.5,
            s: Optional[List[float]] = None,  # We can discuss for this choice
            l0: float = 0.5,
    ):
        self.alpha = alpha
        self.gamma = gamma

        # init s : [s_{t-m}, s_{t-m+1}, ..., s_{t}]
        if s is None:
            self.s = collections.deque([1 for _ in range(m)], maxlen=m)
        else:
            self.s = collections.deque(s, maxlen=m)

        self.lt = l0

    def fit_one(self, y):

        st_1 = self.s[-1]
        st_m = self.s[-self.m]

        lt_1 = self.lt

        self.lt = self.alpha * (y - st_m) + (1 - self.alpha) * lt_1
        st = self.gamma * (y - lt_1) + (1 - self.gamma) * st_m
        self.s.append(st)
        return self

    def forecast(self, horizon: int) -> list:
        return [
            self.lt + self.s[h - self.m * (((h - 1) // self.m) + 1)]
            for h in range(1, horizon + 1)
        ]


#TODO Trend additive damped amd seasonal additive
class AdditiveDampedAdditiveSeasonal(base.Forecaster):  # Need better naming
    """
        #TODO : Docstring + test

    Parameters:
        m (int): m the frequency of the seasonality.
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 . Defaults to `0.5`.
        beta (float): The smoothing parameter for the trend, 0 ≤ beta ≤ 1 . Defaults to `0.5`.
        gamma (float): The smoothing parameter seasonal component 0 ≤ gamma ≤ 1. Defaults to `0.5`.
        phi (float): damping parameter  0 < phi < 1. Defaults to `0.8`.
        s (List[float]): Initialization values for the seasonality. Defaults to `None`.
        l0 (float): Initialization value for the level. Defaults to `0.5`.
        b0 (float): Initialization value for the trend. Defaults to `0.5`.


    Example:
    ::
        >>> #TODO

    References:
        1. `Holt-Winters’ damped method <https://otexts.com/fpp2/holt-winters.html>`_
    """

    def __init__(self,
                 m: int,
                 alpha: float = 0.5,
                 beta: float = 0.5,
                 gamma: float = 0.5,
                 phi: float = 0.5,
                 s: Optional[List[float]] = None,
                 l0: float = 0.5,
                 b0: float = 0.5):

        self.m = m
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.phi = phi

        # init s : [s_{t-m}, s_{t-m+1}, ..., s_{t}]
        if s is None:
            self.s = collections.deque([1 for _ in range(m)], maxlen=m)
        else:
            self.s = collections.deque(s, maxlen=m)

        self.lt = l0
        self.bt = b0

    def fit_one(self, y):

        st_1 = self.s[-1]
        st_m = self.s[-self.m]

        lt_1 = self.lt
        bt_1 = self.bt
        self.lt = self.alpha * (y - st_m) + (1 - self.alpha) * (
            lt_1 + self.phi * bt_1)
        self.bt = self.beta * (self.lt - lt_1) + (
            1 - self.beta) * self.phi * bt_1

        st = self.gamma * (y - lt_1 - self.phi * bt_1) + (1 - self.gamma) * st_m
        self.s.append(st)

    def forecast(self, horizon: int) -> list:
        return [
            self.lt + (_discount_sum(self.phi, h) * self.bt) +
            self.s[h - self.m * (((h - 1) // self.m) + 1)]
            for h in range(1, horizon + 1)
        ]


#TODO Trend no and seasonal Multiplicative
class MultiplicativeSeasonal(base.Forecaster):  # Need better naming
    """
        #TODO : Docstring + test

    Parameters:
        m (int): m the frequency of the seasonality.
        alpha (float): The smoothing parameter for the level, 0 ≤ alpha ≤ 1 . Defaults to `0.5`.
        gamma (float): The smoothing parameter seasonal component 0 ≤ gamma ≤ 1. Defaults to `0.5`.
        s (List[float]): Initialization values for the seasonality. Defaults to `None`.
        l0 (float): Initialization value for the level. Defaults to `0.5`.


    Example:
    ::
        >>> #TODO

    References:
        1. `Multiplicative seasonal method <https://otexts.com/fpp2/taxonomy.html>`_
    """
    def __init__(
            self,
            m: int,
            alpha: float = 0.5,
            gamma: float = 0.5,
            s: Optional[List[float]] = None,  # We can discuss for this choice
            l0: float = 0.5):

        self.m = m

        self.alpha = alpha
        self.gamma = gamma

        # init s : [s_{t-m}, s_{t-m+1}, ..., s_{t}]
        if s is None:
            self.s = collections.deque([1 for _ in range(m)], maxlen=m)
        else:
            self.s = collections.deque(s, maxlen=m)

        self.lt = l0

    def fit_one(self, y: float):

        st_1 = self.s[-1]
        st_m = self.s[-self.m]

        lt_1 = self.lt


        # replace by safe division
        self.lt = self.alpha * (y / st_m) + (1 - self.alpha) * lt_1
        st = self.gamma * (y / lt_1) + (1 - self.gamma) * st_m
        self.s.append(st)

        return self

    def forecast(self, horizon: int) -> list:
        return [
            self.lt * self.s[h - self.m * (((h - 1) // self.m) + 1)]
            for h in range(1, horizon + 1)
        ]
